/*
This file is part of Mitsuba, a physically based rendering system.

Copyright (c) 2007-2014 by Wenzel Jakob and others.

Mitsuba is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License Version 3
as published by the Free Software Foundation.

Mitsuba is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program. If not, see <http://www.gnu.org/licenses/>.
*/

#pragma once
#if !defined(__MITSUBA_PATH_UTILS_H_)
#define __MITSUBA_PATH_UTILS_H_

#include <mitsuba/bidir/pathsampler.h>
#include "camera_storage.h"
#include "upsmcmc.h"
#include "upsmcmc_sampler.h"

MTS_NAMESPACE_BEGIN

struct PathSeedEx;

// PathUtils inherits from PathSampler and adds a new path-sampling features to it.
class PathUtils : public PathSampler {
public:

	/// Specifies the used UPS technique.
	enum EUPSTechnique{
		EBDPT = 1,
		EMERGING = 2,
		EANY = EBDPT | EMERGING
	};

	/**
	* Construct a new path sampler
	*
	* \param scene
	*     \ref A pointer to the underlying scene
	*
	* \param emitterSampler
	*     Sample generator that should be used for the random walk
	*     from the emitter direction
	*
	* \param sensorSampler
	*     Sample generator that should be used for the random walk
	*     from the sensor direction
	*
	* \param directSampler
	*     Sample generator that should be used for direct sampling
	*     strategies (or \c NULL, when \c sampleDirect=\c false)
	*
	* \param config
	*     UPSMCMC integrator config.
    *
	*/
    PathUtils(const Scene *scene, Sampler *emitterSampler,
        Sampler *sensorSampler, Sampler *directSampler,
        const UPSMCMCConfiguration & config);

    /**
    * \brief Computes splats given selected camera vertices
    *
    * \param splats
    *    Output parameter that will receive a list of splats
    *
    * \param cameraStorage
    *     Camera vertices
    *
    * \param cameraPathIndex
    *	  Index of selected camera path
    *
    */
    void sampleLightAndDoUPS(SplatList &list, const CameraStorage * cameraStorage, size_t cameraPathIndex);

    /**
    * \brief Clears memory used by sample splats
    */
    void clearSplats();


    /**
    * \brief Returns emitter sub-path generated by the last call of sample splats (must be called before clearSplats)
    */
    const Path & getEmitterSubPath() const {
        return m_emitterSubpath;
    }

    /**
    * \brief Returns sensor sub-path generated by the last call of sample splats (must be called before clearSplats)
    */
    const Path & getSensorSubPath() const {
        return m_sensorSubpath;
    }

    /**
    * \brief Returns sensor sub-path differential radius
    */
    Float getSensorSubPathRadius() const {
        return m_radius;
    }

    /**
    * \brief Returns sensor sub-path starting pixel
    */
    const Point2 & getSensorSubPathSamplePosition() const {
        return m_samplePos;
    }

    /**
    * Computes the contribution of the specified BDPT sampling strategy given generated vertices.
    * Generated vertices are supplied internally (i.e. sampleSplats generates vertices and supplies them
    * to this method).
    * 
    *
    * \param splats
    *    Output parameter that will receive a list of splats
    *
    * \param ups
    *	  Enables/Disables MIS calculation for UPS (if off only BDPT techniques are considered)
    *
    * \param s
    *	  Number of vertices from a light source (-1 all possible)
    *
    * \param t
    *	  Number of vertices from a camera (-1 all possible)
    *
    * \param radianceWeights
    *     Combined weights along the camera sub-path
    *
    * \param importanceWeights
    *     Combined weights along the light sub-path
    *
    * \param path
    *	  Will be filled with the sampled path (if not null).
    */
    void computeBDPTTechnique(SplatList &list, int s, int t, 
        const Spectrum * importanceWeights, const Spectrum * radianceWeights);

    /**
    * Computes the contribution of the merging sampling strategy given generated light vertices.
    * Generated vertices are supplied internally (i.e. sampleSplats generates vertices and supplies them
    * to this method). 
    *
    * \param splats
    *    Output parameter that will receive a list of splats
    *
    * \param s
    *	  Specifies what photons can be merged (s == -1 all photons)
    *
    * \param t
    *	  Specifies the vertex where merging will be performed (t > 1)
    *
    * \param importanceWeights
    *     Combined weights along the light sub-path
    *
    * \param cameraStorage
    *     Camera storage
    *
    */
    void computeMergingTechnique(SplatList &list, int s, int t,
        const Spectrum * importanceWeights, const CameraStorage * cameraStorage);

    /**
    * \brief Compute the multiple importance sampling weight of the <tt>(s,t,technique)</tt>
    * sampling strategy in BDPT/UPS (depending on the "ups" param)
    *
    * This implementation uses the power heuristic with exponent 2 and
    * repeatedly evaluates equation (10.9) from Eric Veach's PhD thesis to
    * compute the weight in an efficient and numerically stable manner.
    *
    * The function completely ignores the effects of russian roulette, since
    * this allows for a more efficient implementation. The resulting estimator
    * is still unbiased despite this apparent inaccuracy.
    *
    * \param connectionEdge
    *    Pointer to an edge data structure associated with the
    *    transport between <tt>emitterSubpath[s]</tt> and
    *    <tt>sensorSubpath[t]</tt>. Can be NULL for some techniques.
    * \param technique
    *    Used technique (BDPT or MERGING)
    * \param s
    *    Number of steps to take along the emitter subpath
    * \param t
    *    Number of steps to take along the sensor subpath
    * \param ups
    *    Specifies the used algorithm UPS or BDPT.
    */
    Float miWeight(const PathEdge *connectionEdge, int technique, int s, int t);

    /*
    \brief Generate a camera path.
    Generates a camera path starting at an sensor and returns it.

    \param result
    The camera path 
    \param radius
    Ray differential radius
    */
    void generateCameraPath(Path & result, const Point2i &offset = Point2i(-1));

    /**
    * Sets new samplers for the inner path sampler.
    *
    * \param emitterSampler
    *     Sample generator that should be used for the random walk
    *     from the emitter direction
    *
    * \param sensorSampler
    *     Sample generator that should be used for the random walk
    *     from the sensor direction
    *
    * \param directSampler
    *     Sample generator that should be used for direct sampling
    *     strategies (or \c NULL, when \c sampleDirect=\c false)
    */
    inline void replaceSamplers(Sampler *emitterSampler,
        Sampler *sensorSampler, Sampler *directSampler) {
        m_emitterSampler = emitterSampler;
        m_sensorSampler = sensorSampler;
        m_directSampler = directSampler;
    }

	/* Computes radius from ray differentials (uses m_sensorSubpath and m_emitterSubpath)
	*
	* \param time
	*	Sampled time
    *
    * \param s
    *     Number of light vertices.
    *
    * \param t
    *     Number of camera vertices.
	*
	* \return
	* Returns radius
	*/
	Float getRayRadius(Float time, int s, int t) const;


    /* Computes radius from ray differentials using point on camera and point in a scene
    *
    * \param time
    *	Sampled time
    *
    * \param p0
    *     Point on the camera
    *
    * \param p1
    *     Point in the scene
    *
    * \return
    * Returns radius
    */
    Float getRayRadius(Float time, const Point & p0, const Point & p1) const;

    /* Generate initial seeds (for each chain it generates seedCount seeds) using given sample budget)
       The seeds are stored in interleaved order (visibility chain seed, contribution chain seed, visibility chain seed etc)
    */
    void generateSeeds(size_t sampleCount, size_t seedCount, const CameraStorage * cameraStorage, std::vector<PathSeedEx> &seeds);

	MTS_DECLARE_CLASS()


    /// Virtual destructor
    virtual ~PathUtils() {}
	
protected:

    inline double getMergeWeight() const {
        return m_config.isUPS_MCMC() ? m_mergeWeight / m_config.nonVisible : m_mergeWeight;
    }

    inline double getPhotonConnectionWeight(int s) const {
        return m_config.isUPS_MCMC() && s > 1 ? 1. / m_config.nonVisible : 1.;
    }

	const UPSMCMCConfiguration & m_config; 

    // Merging temporary variables
    Path m_tempPath; ///< Stores emitter sub-path while it is replace by photon sub-path
    // For the following two pdfs, we have the following situation:
    // The merging occurs between camera vertex t and photon path vertex s, t -1 and s -1 are the preceding vertices
    // on the sub-paths.
    // Furthermore, the pdf is in area measure if the sampled vertex is connectable and in solid angle measure otherwise.
    Float m_pdfImportance; ///< pdf of sampling vertex t - 1, given vertices s,t
    Float m_pdfRadiance; ///<  pdf of sampling vertex s - 1, given vertices t,s
	Float m_mergeWeight; ///< Merge weight that goes into MIS computation
	Float m_radius; ///< Photon radius merge
    Point2 m_samplePos; ///< Sample position of the last sensor sub-path
    Float m_time; ///< Sampled time
    PathsCache::SimplePath m_cameraPath; ///< Camera path when using computeSplats
};

struct PathSeedEx {
	size_t cameraPathIndex; ///< Connection camera path index
    size_t sampleIndex; ///< Index into a rewindable random number stream
    Float luminance;    ///< Luminance value of the path (for sanity checks)
    inline PathSeedEx(size_t sampleIndex, Float luminance, size_t cameraPathIndex)
        : sampleIndex(sampleIndex), luminance(luminance), cameraPathIndex(cameraPathIndex) {}
};


/*
SeedWorkUnit for all supported MCMC algorithms
*/
class SeedWorkUnitEx : public WorkUnit {
public:
    inline void set(const WorkUnit *wu) {
        m_seeds = static_cast<const SeedWorkUnitEx *>(wu)->m_seeds;
        m_timeout = static_cast<const SeedWorkUnitEx *>(wu)->m_timeout;
        m_workerIndex = static_cast<const SeedWorkUnitEx *>(wu)->m_workerIndex;
    }

    inline void setWorkerIndex(size_t index) {
        m_workerIndex = index;
    }

    inline size_t getWorkerIndex() const {
        return m_workerIndex;
    }

    inline const PathSeedEx &getSeed(size_t chainIndex) const {
        return m_seeds[chainIndex];
    }

    inline void clearSeeds() {
        m_seeds.clear();
    }

    inline void addSeed(const PathSeedEx &seed) {
        m_seeds.push_back(seed);
    }

    inline int getTimeout() const {
        return m_timeout;
    }

    inline void setTimeout(int timeout) {
        m_timeout = timeout;
    }

    inline void load(Stream *stream) {
        SLog(EError, "Streaming is disabled");
    }

    inline void save(Stream *stream) const {
        SLog(EError, "Streaming is disabled");
    }

    inline std::string toString() const {
        return "SeedWorkUnitEx[]";
    }

    MTS_DECLARE_CLASS()
private:
    std::vector<PathSeedEx> m_seeds;
    int m_timeout;
    size_t m_workerIndex;
};

MTS_NAMESPACE_END

#endif /* __MITSUBA_PATH_UTILS_H_ */
